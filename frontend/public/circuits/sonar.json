{"noir_version":"0.34.0+359caafac5e489901d9ff02b08d1a688178d9b0a","hash":10025322066604239712,"abi":{"parameters":[{"name":"ships","type":{"kind":"array","length":15,"type":{"kind":"field"}},"visibility":"private"},{"name":"board_hash","type":{"kind":"field"},"visibility":"public"},{"name":"center_x","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"center_y","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"count","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"69":{"source":"use std::hash::pedersen_hash;\n\n// Ship lengths: carrier(5), battleship(4), cruiser(3), submarine(3), destroyer(2)\nglobal SHIP_LENGTHS: [u8; 5] = [5, 4, 3, 3, 2];\n\nfn main(\n    ships: [Field; 15],\n    board_hash: pub Field,\n    center_x: pub u8,\n    center_y: pub u8,\n    count: pub u8\n) {\n    // Verify ships hash matches board_hash\n    let computed_hash = pedersen_hash(ships);\n    assert(computed_hash == board_hash);\n\n    // Verify center is within grid bounds\n    assert(center_x < 10);\n    assert(center_y < 10);\n\n    // Build 10x10 board grid from ships array\n    let mut grid: [bool; 100] = [false; 100];\n\n    for i in 0..5 {\n        for j in 0..5 {\n            if SHIP_LENGTHS[i] > j as u8 {\n                let x = ships[i * 3];\n                let y = ships[i * 3 + 1];\n                let z = ships[i * 3 + 2];\n\n                let mut coord: Field = (x + j as Field) + y * 10;\n                if z == 1 {\n                    coord = x + (y + j as Field) * 10;\n                }\n\n                grid[coord as u32] = true;\n            }\n        }\n    }\n\n    // Count ship cells in 3x3 area around (center_x, center_y), clamped to 0-9\n    let min_x: u8 = if center_x > 0 { center_x - 1 } else { 0 };\n    let max_x: u8 = if center_x < 9 { center_x + 1 } else { 9 };\n    let min_y: u8 = if center_y > 0 { center_y - 1 } else { 0 };\n    let max_y: u8 = if center_y < 9 { center_y + 1 } else { 9 };\n\n    let mut ship_count: u8 = 0;\n\n    // Iterate over all possible cells in 3x3 range\n    for dy in 0..3 {\n        for dx in 0..3 {\n            let cx = min_x + dx as u8;\n            let cy = min_y + dy as u8;\n            if (cx <= max_x) & (cy <= max_y) {\n                let idx = cx as Field + cy as Field * 10;\n                if grid[idx as u32] {\n                    ship_count += 1;\n                }\n            }\n        }\n    }\n\n    // Assert count matches claimed count\n    assert(ship_count == count);\n}\n\n#[test]\nfn test_sonar_empty_area() {\n    // Ships placed in top rows, sonar on empty bottom-right\n    let ships: [Field; 15] = [\n        0, 0, 0, // carrier(5) at (0,0) horizontal\n        0, 1, 0, // battleship(4) at (0,1) horizontal\n        0, 2, 0, // cruiser(3) at (0,2) horizontal\n        0, 3, 0, // submarine(3) at (0,3) horizontal\n        0, 4, 0  // destroyer(2) at (0,4) horizontal\n    ];\n    let hash = pedersen_hash(ships);\n    main(ships, hash, 8, 8, 0); // Far from all ships → count 0\n}\n\n#[test]\nfn test_sonar_hits_ships() {\n    // Carrier at (0,0) horizontal occupies (0,0)(1,0)(2,0)(3,0)(4,0)\n    // Battleship at (0,1) horizontal occupies (0,1)(1,1)(2,1)(3,1)\n    // Sonar at (1,0) → 3x3 area is (0-2, 0-1) = 6 cells\n    // Ship cells in area: (0,0)(1,0)(2,0) from carrier + (0,1)(1,1)(2,1) from battleship = 6\n    let ships: [Field; 15] = [\n        0, 0, 0, // carrier(5) at (0,0) horizontal\n        0, 1, 0, // battleship(4) at (0,1) horizontal\n        0, 2, 0, // cruiser(3) at (0,2) horizontal\n        0, 3, 0, // submarine(3) at (0,3) horizontal\n        0, 4, 0  // destroyer(2) at (0,4) horizontal\n    ];\n    let hash = pedersen_hash(ships);\n    // Sonar center (1,1): area (0-2, 0-2) = 9 cells\n    // (0,0)=ship (1,0)=ship (2,0)=ship (0,1)=ship (1,1)=ship (2,1)=ship (0,2)=ship (1,2)=ship (2,2)=ship = 9\n    main(ships, hash, 1, 1, 9);\n}\n\n#[test]\nfn test_sonar_corner() {\n    // Sonar at corner (0,0) → 3x3 clamped to (0-1, 0-1) = 4 cells\n    let ships: [Field; 15] = [\n        0, 0, 0, // carrier(5) at (0,0) horizontal\n        0, 1, 0, // battleship(4) at (0,1) horizontal\n        0, 2, 0, // cruiser(3) at (0,2) horizontal\n        0, 3, 0, // submarine(3) at (0,3) horizontal\n        0, 4, 0  // destroyer(2) at (0,4) horizontal\n    ];\n    let hash = pedersen_hash(ships);\n    // Corner (0,0): area (0-1, 0-1) → (0,0)=ship (1,0)=ship (0,1)=ship (1,1)=ship = 4\n    main(ships, hash, 0, 0, 4);\n}\n\n#[test]\nfn test_sonar_edge() {\n    // Sonar at edge (9,5) → 3x3 clamped to (8-9, 4-6) = 6 cells\n    let ships: [Field; 15] = [\n        0, 0, 0,\n        0, 1, 0,\n        0, 2, 0,\n        0, 3, 0,\n        0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    // Edge (9,5): area x=8-9, y=4-6. No ships there → count 0\n    main(ships, hash, 9, 5, 0);\n}\n\n#[test(should_fail)]\nfn test_sonar_wrong_count() {\n    let ships: [Field; 15] = [\n        0, 0, 0,\n        0, 1, 0,\n        0, 2, 0,\n        0, 3, 0,\n        0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    // Claim count 5 at empty area → should fail\n    main(ships, hash, 8, 8, 5);\n}\n\n#[test(should_fail)]\nfn test_sonar_wrong_hash() {\n    let ships: [Field; 15] = [\n        0, 0, 0,\n        0, 1, 0,\n        0, 2, 0,\n        0, 3, 0,\n        0, 4, 0\n    ];\n    // Wrong hash → should fail\n    main(ships, 0, 5, 5, 0);\n}\n\n#[test]\nfn test_sonar_partial_count() {\n    // Mixed layout, sonar should find specific count\n    let ships: [Field; 15] = [\n        0, 0, 0, // carrier(5) at (0,0) horizontal: (0-4, 0)\n        5, 0, 1, // battleship(4) at (5,0) vertical: (5, 0-3)\n        6, 0, 1, // cruiser(3) at (6,0) vertical: (6, 0-2)\n        0, 5, 0, // submarine(3) at (0,5) horizontal: (0-2, 5)\n        7, 7, 1  // destroyer(2) at (7,7) vertical: (7, 7-8)\n    ];\n    let hash = pedersen_hash(ships);\n    // Sonar at (5,1): area (4-6, 0-2) = 9 cells\n    // (4,0)=carrier (5,0)=battleship (6,0)=cruiser\n    // (4,1)=empty (5,1)=battleship (6,1)=cruiser\n    // (4,2)=empty (5,2)=battleship (6,2)=cruiser\n    // Count = 3+2+2 = 7\n    main(ships, hash, 5, 1, 7);\n}\n","path":"/home/ubuntu/dev/zk-battleship/circuits/sonar/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}