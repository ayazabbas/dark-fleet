{"noir_version":"0.34.0+359caafac5e489901d9ff02b08d1a688178d9b0a","hash":891218098033768210,"abi":{"parameters":[{"name":"hash","type":{"kind":"field"},"visibility":"public"},{"name":"hit","type":{"kind":"field"},"visibility":"public"},{"name":"ships","type":{"kind":"array","length":15,"type":{"kind":"field"}},"visibility":"private"},{"name":"shot_x","type":{"kind":"field"},"visibility":"public"},{"name":"shot_y","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"tZvBbtpAEED/xWcOntmd3R1+paoiSCCyhEwEpFKF+Pe6LVDqkETe9h0N+95pn8ZCw7F5Wi1fnx+6fr3dN/Mvx2azfVwcum0/PB2b9tdH+5dF//Npf1jsDs3c3WbNqn9q5tKKnWbNutusmnny0+zNWS1Zz4fVRa+H1U9fZ43c00ur5eqPfusfEL2LDAcviEgaIWE6EqcjNh1J05E8HSnTEZ+OSFvBSAXz+QVQGTOhgokVjFUw71yCcG1MYh4zuYIpFYxPZ7StYKSC0QomVDCxgrEK5vN7YDpmcgVTKhifzoT790D/tKAax8z9exBULkyw8PG8seLns+Y21iurD6w+snr7Z33yy9ncvpnBidVnVl9YvaP62LJ6YfXK6gOrj6yerTay1Ua22shWG9lqja3W2GqNrdbYao2t1thqja3W2GqNrdbYahNbbWKrTWy1ia02sW/IyVh9YvWZ1bPVJrbazFab2WozW21mq83srM3srM3srM3srM1stZmttrDVFrbawlZb2GoLW21hqy1stYWttrDVFrZaZ6t1tlpnq3X2N2Rn35CdfUN29g3Z2WqdrdbZaqVtYb/AfoX9AfZH2G+wP8H+DPsL7If7FbhfgfsVuF+B+xW4X4H7FXb4imTYX2C/s36F+1W4X4X7VbhfhftVuF+F56/C81fh+avw/A1wvwHuN8D9BrjfAPcL708JvEAl8AaVwCtUEuD5+x+WqD72C+xX2A/3Cy9SCbxJJfAqlcC7VAIvUwm8TSXwOpXA+1QCL1QJvFEl8EqVwDtV8t5SVUpXfyl/QcPDctdtNt3zw+1/qoaPvy123WK5WZ0f16/94823h+8vv78ZFD8A","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\nmod sha256;\nmod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\ntrait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"69":{"source":"use std::hash::pedersen_hash;\n\n// Ship lengths: carrier(5), battleship(4), cruiser(3), submarine(3), destroyer(2)\nglobal SHIP_LENGTHS: [u8; 5] = [5, 4, 3, 3, 2];\n\nfn check_hit(ships: [Field; 15], shot_x: Field, shot_y: Field) -> bool {\n    let target = shot_x + shot_y * 10;\n    let mut hit = false;\n\n    for i in 0..5 {\n        for j in 0..5 {\n            if SHIP_LENGTHS[i] > j as u8 {\n                let x = ships[i * 3];\n                let y = ships[i * 3 + 1];\n                let z = ships[i * 3 + 2];\n\n                let mut coord = (x + j as Field) + y * 10;\n                if z == 1 {\n                    coord = x + (y + j as Field) * 10;\n                }\n\n                if coord == target {\n                    hit = true;\n                }\n            }\n        }\n    }\n    hit\n}\n\nfn main(\n    hash: pub Field,\n    hit: pub Field,\n    ships: [Field; 15],\n    shot_x: pub Field,\n    shot_y: pub Field\n) {\n    // Verify board hash matches ship positions\n    let computed_hash = pedersen_hash(ships);\n    assert(hash == computed_hash);\n\n    // Verify shot is within 10x10 grid\n    assert(shot_x as u8 < 10);\n    assert(shot_y as u8 < 10);\n\n    // Verify hit is binary (0 or 1)\n    assert(hit * (hit - 1) == 0);\n\n    // Check if shot actually hits a ship and verify against claimed result\n    let is_hit = check_hit(ships, shot_x, shot_y);\n    assert(hit == is_hit as Field);\n}\n\n#[test]\nfn test_hit_at_origin() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 1, ships, 0, 0); // (0,0) is a hit: carrier starts there\n}\n\n#[test]\nfn test_hit_middle_of_ship() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 1, ships, 3, 0); // (3,0) is a hit: carrier occupies (0-4, 0)\n}\n\n#[test]\nfn test_miss() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 0, ships, 5, 5); // (5,5) is a miss\n}\n\n#[test]\nfn test_hit_vertical_ship() {\n    let ships: [Field; 15] = [\n        0, 0, 1, // carrier(5) at (0,0) vertical: (0, 0-4)\n        1, 0, 1, // battleship(4) at (1,0) vertical\n        2, 0, 1, // cruiser(3) at (2,0) vertical\n        3, 0, 1, // submarine(3) at (3,0) vertical\n        4, 0, 1  // destroyer(2) at (4,0) vertical\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 1, ships, 0, 3); // (0,3) is a hit: carrier occupies (0, 0-4)\n}\n\n#[test(should_fail)]\nfn test_false_hit_claim() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 1, ships, 5, 5); // Claiming hit at empty cell: should fail\n}\n\n#[test(should_fail)]\nfn test_false_miss_claim() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    let hash = pedersen_hash(ships);\n    main(hash, 0, ships, 0, 0); // Claiming miss at (0,0) which is a hit: should fail\n}\n\n#[test(should_fail)]\nfn test_wrong_hash() {\n    let ships: [Field; 15] = [\n        0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0\n    ];\n    main(0, 0, ships, 5, 5); // Wrong hash: should fail\n}\n","path":"/home/ubuntu/dev/zk-battleship/circuits/shot/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}